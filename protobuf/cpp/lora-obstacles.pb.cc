// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lora-obstacles.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "lora-obstacles.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace vutura {
namespace obstacles {
class TagsResponseDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<TagsResponse> {
} _TagsResponse_default_instance_;
class Obstacle_PositionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Obstacle_Position> {
} _Obstacle_Position_default_instance_;
class Obstacle_FenceDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Obstacle_Fence> {
} _Obstacle_Fence_default_instance_;
class ObstacleDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Obstacle> {
} _Obstacle_default_instance_;
class CollisionWarningDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<CollisionWarning> {
} _CollisionWarning_default_instance_;
class CollisionWarningsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<CollisionWarnings> {
} _CollisionWarnings_default_instance_;

namespace protobuf_lora_2dobstacles_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[6];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[1];

}  // namespace

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TagsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TagsResponse, obstacles_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle_Position, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle_Position, latitude_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle_Position, longitude_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle_Position, altitude_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle_Fence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle_Fence, radius_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle_Fence, min_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle_Fence, max_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, fence_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionWarning, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionWarning, timestamp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionWarning, id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionWarning, distance_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionWarnings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionWarnings, warninglist_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(TagsResponse)},
  { 5, -1, sizeof(Obstacle_Position)},
  { 12, -1, sizeof(Obstacle_Fence)},
  { 19, -1, sizeof(Obstacle)},
  { 27, -1, sizeof(CollisionWarning)},
  { 34, -1, sizeof(CollisionWarnings)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_TagsResponse_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Obstacle_Position_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Obstacle_Fence_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Obstacle_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_CollisionWarning_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_CollisionWarnings_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "lora-obstacles.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 6);
}

}  // namespace

void TableStruct::Shutdown() {
  _TagsResponse_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _Obstacle_Position_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _Obstacle_Fence_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _Obstacle_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _CollisionWarning_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _CollisionWarnings_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::google::protobuf::protobuf_google_2fprotobuf_2fempty_2eproto::InitDefaults();
  _TagsResponse_default_instance_.DefaultConstruct();
  _Obstacle_Position_default_instance_.DefaultConstruct();
  _Obstacle_Fence_default_instance_.DefaultConstruct();
  _Obstacle_default_instance_.DefaultConstruct();
  _CollisionWarning_default_instance_.DefaultConstruct();
  _CollisionWarnings_default_instance_.DefaultConstruct();
  _Obstacle_default_instance_.get_mutable()->position_ = const_cast< ::vutura::obstacles::Obstacle_Position*>(
      ::vutura::obstacles::Obstacle_Position::internal_default_instance());
  _Obstacle_default_instance_.get_mutable()->fence_ = const_cast< ::vutura::obstacles::Obstacle_Fence*>(
      ::vutura::obstacles::Obstacle_Fence::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\024lora-obstacles.proto\022\020vutura.obstacles"
      "\032\033google/protobuf/empty.proto\"=\n\014TagsRes"
      "ponse\022-\n\tobstacles\030\001 \003(\0132\032.vutura.obstac"
      "les.Obstacle\"\315\002\n\010Obstacle\022\n\n\002ID\030\001 \001(\r\022-\n"
      "\004type\030\002 \001(\0162\037.vutura.obstacles.Obstacle."
      "Type\0225\n\010position\030\003 \001(\0132#.vutura.obstacle"
      "s.Obstacle.Position\022/\n\005fence\030\004 \001(\0132 .vut"
      "ura.obstacles.Obstacle.Fence\032A\n\010Position"
      "\022\020\n\010latitude\030\001 \001(\002\022\021\n\tlongitude\030\002 \001(\002\022\020\n"
      "\010altitude\030\003 \001(\002\0321\n\005Fence\022\016\n\006radius\030\001 \001(\r"
      "\022\013\n\003min\030\002 \001(\r\022\013\n\003max\030\003 \001(\r\"(\n\004Type\022\020\n\014FI"
      "RE_FIGHTER\020\000\022\016\n\nFIRE_TRUCK\020\001\"C\n\020Collisio"
      "nWarning\022\021\n\ttimestamp\030\001 \001(\004\022\n\n\002ID\030\002 \001(\r\022"
      "\020\n\010distance\030\003 \001(\002\"L\n\021CollisionWarnings\0227"
      "\n\013warningList\030\001 \003(\0132\".vutura.obstacles.C"
      "ollisionWarning2\244\002\n\013TagsService\022A\n\007GetTa"
      "gs\022\026.google.protobuf.Empty\032\036.vutura.obst"
      "acles.TagsResponse\022<\n\006SetTag\022\032.vutura.ob"
      "stacles.Obstacle\032\026.google.protobuf.Empty"
      "\022J\n\013GetWarnings\022\026.google.protobuf.Empty\032"
      "#.vutura.obstacles.CollisionWarnings\022H\n\n"
      "SetWarning\022\".vutura.obstacles.CollisionW"
      "arning\032\026.google.protobuf.Emptyb\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 918);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "lora-obstacles.proto", &protobuf_RegisterTypes);
  ::google::protobuf::protobuf_google_2fprotobuf_2fempty_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_lora_2dobstacles_2eproto

const ::google::protobuf::EnumDescriptor* Obstacle_Type_descriptor() {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_enum_descriptors[0];
}
bool Obstacle_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Obstacle_Type Obstacle::FIRE_FIGHTER;
const Obstacle_Type Obstacle::FIRE_TRUCK;
const Obstacle_Type Obstacle::Type_MIN;
const Obstacle_Type Obstacle::Type_MAX;
const int Obstacle::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TagsResponse::kObstaclesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TagsResponse::TagsResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_lora_2dobstacles_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:vutura.obstacles.TagsResponse)
}
TagsResponse::TagsResponse(const TagsResponse& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      obstacles_(from.obstacles_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vutura.obstacles.TagsResponse)
}

void TagsResponse::SharedCtor() {
  _cached_size_ = 0;
}

TagsResponse::~TagsResponse() {
  // @@protoc_insertion_point(destructor:vutura.obstacles.TagsResponse)
  SharedDtor();
}

void TagsResponse::SharedDtor() {
}

void TagsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TagsResponse::descriptor() {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[0].descriptor;
}

const TagsResponse& TagsResponse::default_instance() {
  protobuf_lora_2dobstacles_2eproto::InitDefaults();
  return *internal_default_instance();
}

TagsResponse* TagsResponse::New(::google::protobuf::Arena* arena) const {
  TagsResponse* n = new TagsResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TagsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:vutura.obstacles.TagsResponse)
  obstacles_.Clear();
}

bool TagsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vutura.obstacles.TagsResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .vutura.obstacles.Obstacle obstacles = 1;
      case 1: {
        if (tag == 10u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_obstacles()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vutura.obstacles.TagsResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vutura.obstacles.TagsResponse)
  return false;
#undef DO_
}

void TagsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vutura.obstacles.TagsResponse)
  // repeated .vutura.obstacles.Obstacle obstacles = 1;
  for (unsigned int i = 0, n = this->obstacles_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->obstacles(i), output);
  }

  // @@protoc_insertion_point(serialize_end:vutura.obstacles.TagsResponse)
}

::google::protobuf::uint8* TagsResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:vutura.obstacles.TagsResponse)
  // repeated .vutura.obstacles.Obstacle obstacles = 1;
  for (unsigned int i = 0, n = this->obstacles_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->obstacles(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:vutura.obstacles.TagsResponse)
  return target;
}

size_t TagsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vutura.obstacles.TagsResponse)
  size_t total_size = 0;

  // repeated .vutura.obstacles.Obstacle obstacles = 1;
  {
    unsigned int count = this->obstacles_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->obstacles(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TagsResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vutura.obstacles.TagsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const TagsResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TagsResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vutura.obstacles.TagsResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vutura.obstacles.TagsResponse)
    MergeFrom(*source);
  }
}

void TagsResponse::MergeFrom(const TagsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vutura.obstacles.TagsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  obstacles_.MergeFrom(from.obstacles_);
}

void TagsResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vutura.obstacles.TagsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TagsResponse::CopyFrom(const TagsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vutura.obstacles.TagsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TagsResponse::IsInitialized() const {
  return true;
}

void TagsResponse::Swap(TagsResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TagsResponse::InternalSwap(TagsResponse* other) {
  obstacles_.UnsafeArenaSwap(&other->obstacles_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TagsResponse::GetMetadata() const {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[0];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TagsResponse

// repeated .vutura.obstacles.Obstacle obstacles = 1;
int TagsResponse::obstacles_size() const {
  return obstacles_.size();
}
void TagsResponse::clear_obstacles() {
  obstacles_.Clear();
}
const ::vutura::obstacles::Obstacle& TagsResponse::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.TagsResponse.obstacles)
  return obstacles_.Get(index);
}
::vutura::obstacles::Obstacle* TagsResponse::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:vutura.obstacles.TagsResponse.obstacles)
  return obstacles_.Mutable(index);
}
::vutura::obstacles::Obstacle* TagsResponse::add_obstacles() {
  // @@protoc_insertion_point(field_add:vutura.obstacles.TagsResponse.obstacles)
  return obstacles_.Add();
}
::google::protobuf::RepeatedPtrField< ::vutura::obstacles::Obstacle >*
TagsResponse::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:vutura.obstacles.TagsResponse.obstacles)
  return &obstacles_;
}
const ::google::protobuf::RepeatedPtrField< ::vutura::obstacles::Obstacle >&
TagsResponse::obstacles() const {
  // @@protoc_insertion_point(field_list:vutura.obstacles.TagsResponse.obstacles)
  return obstacles_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacle_Position::kLatitudeFieldNumber;
const int Obstacle_Position::kLongitudeFieldNumber;
const int Obstacle_Position::kAltitudeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacle_Position::Obstacle_Position()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_lora_2dobstacles_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:vutura.obstacles.Obstacle.Position)
}
Obstacle_Position::Obstacle_Position(const Obstacle_Position& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&latitude_, &from.latitude_,
    reinterpret_cast<char*>(&altitude_) -
    reinterpret_cast<char*>(&latitude_) + sizeof(altitude_));
  // @@protoc_insertion_point(copy_constructor:vutura.obstacles.Obstacle.Position)
}

void Obstacle_Position::SharedCtor() {
  ::memset(&latitude_, 0, reinterpret_cast<char*>(&altitude_) -
    reinterpret_cast<char*>(&latitude_) + sizeof(altitude_));
  _cached_size_ = 0;
}

Obstacle_Position::~Obstacle_Position() {
  // @@protoc_insertion_point(destructor:vutura.obstacles.Obstacle.Position)
  SharedDtor();
}

void Obstacle_Position::SharedDtor() {
}

void Obstacle_Position::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Obstacle_Position::descriptor() {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[1].descriptor;
}

const Obstacle_Position& Obstacle_Position::default_instance() {
  protobuf_lora_2dobstacles_2eproto::InitDefaults();
  return *internal_default_instance();
}

Obstacle_Position* Obstacle_Position::New(::google::protobuf::Arena* arena) const {
  Obstacle_Position* n = new Obstacle_Position;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Obstacle_Position::Clear() {
// @@protoc_insertion_point(message_clear_start:vutura.obstacles.Obstacle.Position)
  ::memset(&latitude_, 0, reinterpret_cast<char*>(&altitude_) -
    reinterpret_cast<char*>(&latitude_) + sizeof(altitude_));
}

bool Obstacle_Position::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vutura.obstacles.Obstacle.Position)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float latitude = 1;
      case 1: {
        if (tag == 13u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &latitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float longitude = 2;
      case 2: {
        if (tag == 21u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &longitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float altitude = 3;
      case 3: {
        if (tag == 29u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &altitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vutura.obstacles.Obstacle.Position)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vutura.obstacles.Obstacle.Position)
  return false;
#undef DO_
}

void Obstacle_Position::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vutura.obstacles.Obstacle.Position)
  // float latitude = 1;
  if (this->latitude() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->latitude(), output);
  }

  // float longitude = 2;
  if (this->longitude() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->longitude(), output);
  }

  // float altitude = 3;
  if (this->altitude() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->altitude(), output);
  }

  // @@protoc_insertion_point(serialize_end:vutura.obstacles.Obstacle.Position)
}

::google::protobuf::uint8* Obstacle_Position::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:vutura.obstacles.Obstacle.Position)
  // float latitude = 1;
  if (this->latitude() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->latitude(), target);
  }

  // float longitude = 2;
  if (this->longitude() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->longitude(), target);
  }

  // float altitude = 3;
  if (this->altitude() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->altitude(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:vutura.obstacles.Obstacle.Position)
  return target;
}

size_t Obstacle_Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vutura.obstacles.Obstacle.Position)
  size_t total_size = 0;

  // float latitude = 1;
  if (this->latitude() != 0) {
    total_size += 1 + 4;
  }

  // float longitude = 2;
  if (this->longitude() != 0) {
    total_size += 1 + 4;
  }

  // float altitude = 3;
  if (this->altitude() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Obstacle_Position::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vutura.obstacles.Obstacle.Position)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacle_Position* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Obstacle_Position>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vutura.obstacles.Obstacle.Position)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vutura.obstacles.Obstacle.Position)
    MergeFrom(*source);
  }
}

void Obstacle_Position::MergeFrom(const Obstacle_Position& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vutura.obstacles.Obstacle.Position)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.latitude() != 0) {
    set_latitude(from.latitude());
  }
  if (from.longitude() != 0) {
    set_longitude(from.longitude());
  }
  if (from.altitude() != 0) {
    set_altitude(from.altitude());
  }
}

void Obstacle_Position::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vutura.obstacles.Obstacle.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle_Position::CopyFrom(const Obstacle_Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vutura.obstacles.Obstacle.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle_Position::IsInitialized() const {
  return true;
}

void Obstacle_Position::Swap(Obstacle_Position* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacle_Position::InternalSwap(Obstacle_Position* other) {
  std::swap(latitude_, other->latitude_);
  std::swap(longitude_, other->longitude_);
  std::swap(altitude_, other->altitude_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Obstacle_Position::GetMetadata() const {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[1];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Obstacle_Position

// float latitude = 1;
void Obstacle_Position::clear_latitude() {
  latitude_ = 0;
}
float Obstacle_Position::latitude() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.Position.latitude)
  return latitude_;
}
void Obstacle_Position::set_latitude(float value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.Obstacle.Position.latitude)
}

// float longitude = 2;
void Obstacle_Position::clear_longitude() {
  longitude_ = 0;
}
float Obstacle_Position::longitude() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.Position.longitude)
  return longitude_;
}
void Obstacle_Position::set_longitude(float value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.Obstacle.Position.longitude)
}

// float altitude = 3;
void Obstacle_Position::clear_altitude() {
  altitude_ = 0;
}
float Obstacle_Position::altitude() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.Position.altitude)
  return altitude_;
}
void Obstacle_Position::set_altitude(float value) {
  
  altitude_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.Obstacle.Position.altitude)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacle_Fence::kRadiusFieldNumber;
const int Obstacle_Fence::kMinFieldNumber;
const int Obstacle_Fence::kMaxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacle_Fence::Obstacle_Fence()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_lora_2dobstacles_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:vutura.obstacles.Obstacle.Fence)
}
Obstacle_Fence::Obstacle_Fence(const Obstacle_Fence& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&radius_, &from.radius_,
    reinterpret_cast<char*>(&max_) -
    reinterpret_cast<char*>(&radius_) + sizeof(max_));
  // @@protoc_insertion_point(copy_constructor:vutura.obstacles.Obstacle.Fence)
}

void Obstacle_Fence::SharedCtor() {
  ::memset(&radius_, 0, reinterpret_cast<char*>(&max_) -
    reinterpret_cast<char*>(&radius_) + sizeof(max_));
  _cached_size_ = 0;
}

Obstacle_Fence::~Obstacle_Fence() {
  // @@protoc_insertion_point(destructor:vutura.obstacles.Obstacle.Fence)
  SharedDtor();
}

void Obstacle_Fence::SharedDtor() {
}

void Obstacle_Fence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Obstacle_Fence::descriptor() {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[2].descriptor;
}

const Obstacle_Fence& Obstacle_Fence::default_instance() {
  protobuf_lora_2dobstacles_2eproto::InitDefaults();
  return *internal_default_instance();
}

Obstacle_Fence* Obstacle_Fence::New(::google::protobuf::Arena* arena) const {
  Obstacle_Fence* n = new Obstacle_Fence;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Obstacle_Fence::Clear() {
// @@protoc_insertion_point(message_clear_start:vutura.obstacles.Obstacle.Fence)
  ::memset(&radius_, 0, reinterpret_cast<char*>(&max_) -
    reinterpret_cast<char*>(&radius_) + sizeof(max_));
}

bool Obstacle_Fence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vutura.obstacles.Obstacle.Fence)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 radius = 1;
      case 1: {
        if (tag == 8u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &radius_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 min = 2;
      case 2: {
        if (tag == 16u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 max = 3;
      case 3: {
        if (tag == 24u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vutura.obstacles.Obstacle.Fence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vutura.obstacles.Obstacle.Fence)
  return false;
#undef DO_
}

void Obstacle_Fence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vutura.obstacles.Obstacle.Fence)
  // uint32 radius = 1;
  if (this->radius() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->radius(), output);
  }

  // uint32 min = 2;
  if (this->min() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->min(), output);
  }

  // uint32 max = 3;
  if (this->max() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->max(), output);
  }

  // @@protoc_insertion_point(serialize_end:vutura.obstacles.Obstacle.Fence)
}

::google::protobuf::uint8* Obstacle_Fence::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:vutura.obstacles.Obstacle.Fence)
  // uint32 radius = 1;
  if (this->radius() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->radius(), target);
  }

  // uint32 min = 2;
  if (this->min() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->min(), target);
  }

  // uint32 max = 3;
  if (this->max() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->max(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:vutura.obstacles.Obstacle.Fence)
  return target;
}

size_t Obstacle_Fence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vutura.obstacles.Obstacle.Fence)
  size_t total_size = 0;

  // uint32 radius = 1;
  if (this->radius() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->radius());
  }

  // uint32 min = 2;
  if (this->min() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->min());
  }

  // uint32 max = 3;
  if (this->max() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->max());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Obstacle_Fence::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vutura.obstacles.Obstacle.Fence)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacle_Fence* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Obstacle_Fence>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vutura.obstacles.Obstacle.Fence)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vutura.obstacles.Obstacle.Fence)
    MergeFrom(*source);
  }
}

void Obstacle_Fence::MergeFrom(const Obstacle_Fence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vutura.obstacles.Obstacle.Fence)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.radius() != 0) {
    set_radius(from.radius());
  }
  if (from.min() != 0) {
    set_min(from.min());
  }
  if (from.max() != 0) {
    set_max(from.max());
  }
}

void Obstacle_Fence::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vutura.obstacles.Obstacle.Fence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle_Fence::CopyFrom(const Obstacle_Fence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vutura.obstacles.Obstacle.Fence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle_Fence::IsInitialized() const {
  return true;
}

void Obstacle_Fence::Swap(Obstacle_Fence* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacle_Fence::InternalSwap(Obstacle_Fence* other) {
  std::swap(radius_, other->radius_);
  std::swap(min_, other->min_);
  std::swap(max_, other->max_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Obstacle_Fence::GetMetadata() const {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[2];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Obstacle_Fence

// uint32 radius = 1;
void Obstacle_Fence::clear_radius() {
  radius_ = 0u;
}
::google::protobuf::uint32 Obstacle_Fence::radius() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.Fence.radius)
  return radius_;
}
void Obstacle_Fence::set_radius(::google::protobuf::uint32 value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.Obstacle.Fence.radius)
}

// uint32 min = 2;
void Obstacle_Fence::clear_min() {
  min_ = 0u;
}
::google::protobuf::uint32 Obstacle_Fence::min() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.Fence.min)
  return min_;
}
void Obstacle_Fence::set_min(::google::protobuf::uint32 value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.Obstacle.Fence.min)
}

// uint32 max = 3;
void Obstacle_Fence::clear_max() {
  max_ = 0u;
}
::google::protobuf::uint32 Obstacle_Fence::max() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.Fence.max)
  return max_;
}
void Obstacle_Fence::set_max(::google::protobuf::uint32 value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.Obstacle.Fence.max)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacle::kIDFieldNumber;
const int Obstacle::kTypeFieldNumber;
const int Obstacle::kPositionFieldNumber;
const int Obstacle::kFenceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacle::Obstacle()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_lora_2dobstacles_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:vutura.obstacles.Obstacle)
}
Obstacle::Obstacle(const Obstacle& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::vutura::obstacles::Obstacle_Position(*from.position_);
  } else {
    position_ = NULL;
  }
  if (from.has_fence()) {
    fence_ = new ::vutura::obstacles::Obstacle_Fence(*from.fence_);
  } else {
    fence_ = NULL;
  }
  ::memcpy(&id_, &from.id_,
    reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&id_) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:vutura.obstacles.Obstacle)
}

void Obstacle::SharedCtor() {
  ::memset(&position_, 0, reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&position_) + sizeof(type_));
  _cached_size_ = 0;
}

Obstacle::~Obstacle() {
  // @@protoc_insertion_point(destructor:vutura.obstacles.Obstacle)
  SharedDtor();
}

void Obstacle::SharedDtor() {
  if (this != internal_default_instance()) {
    delete position_;
  }
  if (this != internal_default_instance()) {
    delete fence_;
  }
}

void Obstacle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Obstacle::descriptor() {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[3].descriptor;
}

const Obstacle& Obstacle::default_instance() {
  protobuf_lora_2dobstacles_2eproto::InitDefaults();
  return *internal_default_instance();
}

Obstacle* Obstacle::New(::google::protobuf::Arena* arena) const {
  Obstacle* n = new Obstacle;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Obstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:vutura.obstacles.Obstacle)
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  if (GetArenaNoVirtual() == NULL && fence_ != NULL) {
    delete fence_;
  }
  fence_ = NULL;
  ::memset(&id_, 0, reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&id_) + sizeof(type_));
}

bool Obstacle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vutura.obstacles.Obstacle)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 ID = 1;
      case 1: {
        if (tag == 8u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vutura.obstacles.Obstacle.Type type = 2;
      case 2: {
        if (tag == 16u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::vutura::obstacles::Obstacle_Type >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vutura.obstacles.Obstacle.Position position = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .vutura.obstacles.Obstacle.Fence fence = 4;
      case 4: {
        if (tag == 34u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vutura.obstacles.Obstacle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vutura.obstacles.Obstacle)
  return false;
#undef DO_
}

void Obstacle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vutura.obstacles.Obstacle)
  // uint32 ID = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // .vutura.obstacles.Obstacle.Type type = 2;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // .vutura.obstacles.Obstacle.Position position = 3;
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->position_, output);
  }

  // .vutura.obstacles.Obstacle.Fence fence = 4;
  if (this->has_fence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->fence_, output);
  }

  // @@protoc_insertion_point(serialize_end:vutura.obstacles.Obstacle)
}

::google::protobuf::uint8* Obstacle::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:vutura.obstacles.Obstacle)
  // uint32 ID = 1;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // .vutura.obstacles.Obstacle.Type type = 2;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // .vutura.obstacles.Obstacle.Position position = 3;
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->position_, false, target);
  }

  // .vutura.obstacles.Obstacle.Fence fence = 4;
  if (this->has_fence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->fence_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:vutura.obstacles.Obstacle)
  return target;
}

size_t Obstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vutura.obstacles.Obstacle)
  size_t total_size = 0;

  // .vutura.obstacles.Obstacle.Position position = 3;
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);
  }

  // .vutura.obstacles.Obstacle.Fence fence = 4;
  if (this->has_fence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->fence_);
  }

  // uint32 ID = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  // .vutura.obstacles.Obstacle.Type type = 2;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Obstacle::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vutura.obstacles.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacle* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Obstacle>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vutura.obstacles.Obstacle)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vutura.obstacles.Obstacle)
    MergeFrom(*source);
  }
}

void Obstacle::MergeFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vutura.obstacles.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    mutable_position()->::vutura::obstacles::Obstacle_Position::MergeFrom(from.position());
  }
  if (from.has_fence()) {
    mutable_fence()->::vutura::obstacles::Obstacle_Fence::MergeFrom(from.fence());
  }
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void Obstacle::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vutura.obstacles.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle::CopyFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vutura.obstacles.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle::IsInitialized() const {
  return true;
}

void Obstacle::Swap(Obstacle* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacle::InternalSwap(Obstacle* other) {
  std::swap(position_, other->position_);
  std::swap(fence_, other->fence_);
  std::swap(id_, other->id_);
  std::swap(type_, other->type_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Obstacle::GetMetadata() const {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[3];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Obstacle

// uint32 ID = 1;
void Obstacle::clear_id() {
  id_ = 0u;
}
::google::protobuf::uint32 Obstacle::id() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.ID)
  return id_;
}
void Obstacle::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.Obstacle.ID)
}

// .vutura.obstacles.Obstacle.Type type = 2;
void Obstacle::clear_type() {
  type_ = 0;
}
::vutura::obstacles::Obstacle_Type Obstacle::type() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.type)
  return static_cast< ::vutura::obstacles::Obstacle_Type >(type_);
}
void Obstacle::set_type(::vutura::obstacles::Obstacle_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.Obstacle.type)
}

// .vutura.obstacles.Obstacle.Position position = 3;
bool Obstacle::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
void Obstacle::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) delete position_;
  position_ = NULL;
}
const ::vutura::obstacles::Obstacle_Position& Obstacle::position() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.position)
  return position_ != NULL ? *position_
                         : *::vutura::obstacles::Obstacle_Position::internal_default_instance();
}
::vutura::obstacles::Obstacle_Position* Obstacle::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::vutura::obstacles::Obstacle_Position;
  }
  // @@protoc_insertion_point(field_mutable:vutura.obstacles.Obstacle.position)
  return position_;
}
::vutura::obstacles::Obstacle_Position* Obstacle::release_position() {
  // @@protoc_insertion_point(field_release:vutura.obstacles.Obstacle.position)
  
  ::vutura::obstacles::Obstacle_Position* temp = position_;
  position_ = NULL;
  return temp;
}
void Obstacle::set_allocated_position(::vutura::obstacles::Obstacle_Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vutura.obstacles.Obstacle.position)
}

// .vutura.obstacles.Obstacle.Fence fence = 4;
bool Obstacle::has_fence() const {
  return this != internal_default_instance() && fence_ != NULL;
}
void Obstacle::clear_fence() {
  if (GetArenaNoVirtual() == NULL && fence_ != NULL) delete fence_;
  fence_ = NULL;
}
const ::vutura::obstacles::Obstacle_Fence& Obstacle::fence() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.Obstacle.fence)
  return fence_ != NULL ? *fence_
                         : *::vutura::obstacles::Obstacle_Fence::internal_default_instance();
}
::vutura::obstacles::Obstacle_Fence* Obstacle::mutable_fence() {
  
  if (fence_ == NULL) {
    fence_ = new ::vutura::obstacles::Obstacle_Fence;
  }
  // @@protoc_insertion_point(field_mutable:vutura.obstacles.Obstacle.fence)
  return fence_;
}
::vutura::obstacles::Obstacle_Fence* Obstacle::release_fence() {
  // @@protoc_insertion_point(field_release:vutura.obstacles.Obstacle.fence)
  
  ::vutura::obstacles::Obstacle_Fence* temp = fence_;
  fence_ = NULL;
  return temp;
}
void Obstacle::set_allocated_fence(::vutura::obstacles::Obstacle_Fence* fence) {
  delete fence_;
  fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vutura.obstacles.Obstacle.fence)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CollisionWarning::kTimestampFieldNumber;
const int CollisionWarning::kIDFieldNumber;
const int CollisionWarning::kDistanceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CollisionWarning::CollisionWarning()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_lora_2dobstacles_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:vutura.obstacles.CollisionWarning)
}
CollisionWarning::CollisionWarning(const CollisionWarning& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&timestamp_) + sizeof(distance_));
  // @@protoc_insertion_point(copy_constructor:vutura.obstacles.CollisionWarning)
}

void CollisionWarning::SharedCtor() {
  ::memset(&timestamp_, 0, reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&timestamp_) + sizeof(distance_));
  _cached_size_ = 0;
}

CollisionWarning::~CollisionWarning() {
  // @@protoc_insertion_point(destructor:vutura.obstacles.CollisionWarning)
  SharedDtor();
}

void CollisionWarning::SharedDtor() {
}

void CollisionWarning::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollisionWarning::descriptor() {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[4].descriptor;
}

const CollisionWarning& CollisionWarning::default_instance() {
  protobuf_lora_2dobstacles_2eproto::InitDefaults();
  return *internal_default_instance();
}

CollisionWarning* CollisionWarning::New(::google::protobuf::Arena* arena) const {
  CollisionWarning* n = new CollisionWarning;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CollisionWarning::Clear() {
// @@protoc_insertion_point(message_clear_start:vutura.obstacles.CollisionWarning)
  ::memset(&timestamp_, 0, reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&timestamp_) + sizeof(distance_));
}

bool CollisionWarning::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vutura.obstacles.CollisionWarning)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 timestamp = 1;
      case 1: {
        if (tag == 8u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 ID = 2;
      case 2: {
        if (tag == 16u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float distance = 3;
      case 3: {
        if (tag == 29u) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vutura.obstacles.CollisionWarning)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vutura.obstacles.CollisionWarning)
  return false;
#undef DO_
}

void CollisionWarning::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vutura.obstacles.CollisionWarning)
  // uint64 timestamp = 1;
  if (this->timestamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->timestamp(), output);
  }

  // uint32 ID = 2;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  // float distance = 3;
  if (this->distance() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->distance(), output);
  }

  // @@protoc_insertion_point(serialize_end:vutura.obstacles.CollisionWarning)
}

::google::protobuf::uint8* CollisionWarning::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:vutura.obstacles.CollisionWarning)
  // uint64 timestamp = 1;
  if (this->timestamp() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->timestamp(), target);
  }

  // uint32 ID = 2;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->id(), target);
  }

  // float distance = 3;
  if (this->distance() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->distance(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:vutura.obstacles.CollisionWarning)
  return target;
}

size_t CollisionWarning::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vutura.obstacles.CollisionWarning)
  size_t total_size = 0;

  // uint64 timestamp = 1;
  if (this->timestamp() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->timestamp());
  }

  // uint32 ID = 2;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  // float distance = 3;
  if (this->distance() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollisionWarning::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vutura.obstacles.CollisionWarning)
  GOOGLE_DCHECK_NE(&from, this);
  const CollisionWarning* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CollisionWarning>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vutura.obstacles.CollisionWarning)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vutura.obstacles.CollisionWarning)
    MergeFrom(*source);
  }
}

void CollisionWarning::MergeFrom(const CollisionWarning& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vutura.obstacles.CollisionWarning)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.timestamp() != 0) {
    set_timestamp(from.timestamp());
  }
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.distance() != 0) {
    set_distance(from.distance());
  }
}

void CollisionWarning::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vutura.obstacles.CollisionWarning)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollisionWarning::CopyFrom(const CollisionWarning& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vutura.obstacles.CollisionWarning)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollisionWarning::IsInitialized() const {
  return true;
}

void CollisionWarning::Swap(CollisionWarning* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CollisionWarning::InternalSwap(CollisionWarning* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(id_, other->id_);
  std::swap(distance_, other->distance_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CollisionWarning::GetMetadata() const {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[4];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CollisionWarning

// uint64 timestamp = 1;
void CollisionWarning::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
::google::protobuf::uint64 CollisionWarning::timestamp() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.CollisionWarning.timestamp)
  return timestamp_;
}
void CollisionWarning::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.CollisionWarning.timestamp)
}

// uint32 ID = 2;
void CollisionWarning::clear_id() {
  id_ = 0u;
}
::google::protobuf::uint32 CollisionWarning::id() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.CollisionWarning.ID)
  return id_;
}
void CollisionWarning::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.CollisionWarning.ID)
}

// float distance = 3;
void CollisionWarning::clear_distance() {
  distance_ = 0;
}
float CollisionWarning::distance() const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.CollisionWarning.distance)
  return distance_;
}
void CollisionWarning::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:vutura.obstacles.CollisionWarning.distance)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CollisionWarnings::kWarningListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CollisionWarnings::CollisionWarnings()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_lora_2dobstacles_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:vutura.obstacles.CollisionWarnings)
}
CollisionWarnings::CollisionWarnings(const CollisionWarnings& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      warninglist_(from.warninglist_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vutura.obstacles.CollisionWarnings)
}

void CollisionWarnings::SharedCtor() {
  _cached_size_ = 0;
}

CollisionWarnings::~CollisionWarnings() {
  // @@protoc_insertion_point(destructor:vutura.obstacles.CollisionWarnings)
  SharedDtor();
}

void CollisionWarnings::SharedDtor() {
}

void CollisionWarnings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollisionWarnings::descriptor() {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[5].descriptor;
}

const CollisionWarnings& CollisionWarnings::default_instance() {
  protobuf_lora_2dobstacles_2eproto::InitDefaults();
  return *internal_default_instance();
}

CollisionWarnings* CollisionWarnings::New(::google::protobuf::Arena* arena) const {
  CollisionWarnings* n = new CollisionWarnings;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CollisionWarnings::Clear() {
// @@protoc_insertion_point(message_clear_start:vutura.obstacles.CollisionWarnings)
  warninglist_.Clear();
}

bool CollisionWarnings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vutura.obstacles.CollisionWarnings)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .vutura.obstacles.CollisionWarning warningList = 1;
      case 1: {
        if (tag == 10u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_warninglist()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vutura.obstacles.CollisionWarnings)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vutura.obstacles.CollisionWarnings)
  return false;
#undef DO_
}

void CollisionWarnings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vutura.obstacles.CollisionWarnings)
  // repeated .vutura.obstacles.CollisionWarning warningList = 1;
  for (unsigned int i = 0, n = this->warninglist_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->warninglist(i), output);
  }

  // @@protoc_insertion_point(serialize_end:vutura.obstacles.CollisionWarnings)
}

::google::protobuf::uint8* CollisionWarnings::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:vutura.obstacles.CollisionWarnings)
  // repeated .vutura.obstacles.CollisionWarning warningList = 1;
  for (unsigned int i = 0, n = this->warninglist_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->warninglist(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:vutura.obstacles.CollisionWarnings)
  return target;
}

size_t CollisionWarnings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vutura.obstacles.CollisionWarnings)
  size_t total_size = 0;

  // repeated .vutura.obstacles.CollisionWarning warningList = 1;
  {
    unsigned int count = this->warninglist_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->warninglist(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollisionWarnings::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vutura.obstacles.CollisionWarnings)
  GOOGLE_DCHECK_NE(&from, this);
  const CollisionWarnings* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CollisionWarnings>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vutura.obstacles.CollisionWarnings)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vutura.obstacles.CollisionWarnings)
    MergeFrom(*source);
  }
}

void CollisionWarnings::MergeFrom(const CollisionWarnings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vutura.obstacles.CollisionWarnings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  warninglist_.MergeFrom(from.warninglist_);
}

void CollisionWarnings::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vutura.obstacles.CollisionWarnings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollisionWarnings::CopyFrom(const CollisionWarnings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vutura.obstacles.CollisionWarnings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollisionWarnings::IsInitialized() const {
  return true;
}

void CollisionWarnings::Swap(CollisionWarnings* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CollisionWarnings::InternalSwap(CollisionWarnings* other) {
  warninglist_.UnsafeArenaSwap(&other->warninglist_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CollisionWarnings::GetMetadata() const {
  protobuf_lora_2dobstacles_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_lora_2dobstacles_2eproto::file_level_metadata[5];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CollisionWarnings

// repeated .vutura.obstacles.CollisionWarning warningList = 1;
int CollisionWarnings::warninglist_size() const {
  return warninglist_.size();
}
void CollisionWarnings::clear_warninglist() {
  warninglist_.Clear();
}
const ::vutura::obstacles::CollisionWarning& CollisionWarnings::warninglist(int index) const {
  // @@protoc_insertion_point(field_get:vutura.obstacles.CollisionWarnings.warningList)
  return warninglist_.Get(index);
}
::vutura::obstacles::CollisionWarning* CollisionWarnings::mutable_warninglist(int index) {
  // @@protoc_insertion_point(field_mutable:vutura.obstacles.CollisionWarnings.warningList)
  return warninglist_.Mutable(index);
}
::vutura::obstacles::CollisionWarning* CollisionWarnings::add_warninglist() {
  // @@protoc_insertion_point(field_add:vutura.obstacles.CollisionWarnings.warningList)
  return warninglist_.Add();
}
::google::protobuf::RepeatedPtrField< ::vutura::obstacles::CollisionWarning >*
CollisionWarnings::mutable_warninglist() {
  // @@protoc_insertion_point(field_mutable_list:vutura.obstacles.CollisionWarnings.warningList)
  return &warninglist_;
}
const ::google::protobuf::RepeatedPtrField< ::vutura::obstacles::CollisionWarning >&
CollisionWarnings::warninglist() const {
  // @@protoc_insertion_point(field_list:vutura.obstacles.CollisionWarnings.warningList)
  return warninglist_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace obstacles
}  // namespace vutura

// @@protoc_insertion_point(global_scope)
